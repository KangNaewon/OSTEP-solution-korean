1.  다음과 같이 플래그를 지정하고 프로그램을 실행시키시오: ./process-run.py -l 5:100,5:100.
    CPU 이용률은 얼마가 되어야 하는가(예, CPU가 사용 중인 시간의 퍼센트?) 그러한 이용률을 예측한 이유는
    무엇인가? -c 플래글 지정하여 예측이 맞는지 확인하시오

A.  CPU 이용률은 100%이다. IO 작업이 없기 때문이다.

2.  이제 다음과 같이 플래그를 지정하고 실행시키시오: ./process-run.py -l 4:100, 1:0. 
    이 플래그는 4발의 명령어를 실행하고 모두 CPU만 사용하는 하나의 프로세스와 오직 입출력을 요청하고
    완료되기를 기다리는 하나의 프로세스를 명시한다. 두 프로세스가 모두 종료되는 데 얼마의 시간이 걸리는가?
     -c 플래그를 사용하여 예측한 것이 맞는지 확인하시오.

A.  11 ticks. PID 0 프로세스 실행(4), PID 1 프로세스 IO 작업 실행(1), IO 작업 실행 동안 PID 1 프로세스 대기 상태(5), IO 작업 종료(1)

3.  옵션으로 지정된 프로세스의 순서를 바꾸시오: ./process-run.py -l 1:0, 4:100. 
    이제 어떤 결과가 나오는가? 실행 순서를 교환하는 것은 중요한가? 이유는 무엇인가? 
    (언제나처럼 -c 플래그를 사용하여 예측이 맞는지 확인하시오.)

A.Time        PID: 0        PID: 1           CPU           IOs
    1         RUN:io         READY             1          
    2        BLOCKED       RUN:cpu             1             1
    3        BLOCKED       RUN:cpu             1             1
    4        BLOCKED       RUN:cpu             1             1
    5        BLOCKED       RUN:cpu             1             1
    6        BLOCKED          DONE                           1
    7*   RUN:io_done          DONE             1          

    대기 상태동안 다른 프로세스를 실행할 수 있기 때문에 IO 작업이 있는 프로세스를 먼저 실행하는 것이 성능 상 유리하다.

4.  자, 다른 플래그에 대해서도 알아보자. 중요한 플래그 중 하나는 -S로서 프로세 스가 입출력을 요청했을 때
    시스템이 어떻게 반응하는지를 결정한다. 이 플래그가 SWITCH_ON_END로 지정되면 시스템은 요청 프로세스가
    입출력을 하는 동안 다른 프로세스로 전환하지 않고 대신 요청 프로세스가 종료될 때까지 기다린다. 
    입출력만 수행하는 프로세스와 CPU 작􏰂만 하는 프로세스 두 발를 실행시키면 어떤 결과가 발생하는가?
    (-l 1:0,4:200 -c -S SWITCH_ON_END)

A.Time        PID: 0        PID: 1           CPU           IOs
    1         RUN:io         READY             1          
    2        BLOCKED         READY                           1
    3        BLOCKED         READY                           1
    4        BLOCKED         READY                           1
    5        BLOCKED         READY                           1
    6        BLOCKED         READY                           1
    7*   RUN:io_done         READY             1          
    8           DONE       RUN:cpu             1          
    9           DONE       RUN:cpu             1          
    10           DONE       RUN:cpu             1          
    11           DONE       RUN:cpu             1       

    대기 상태동안 다른 프로세스가 실행되지 않기 때문에 프로세스 순서를 바꾸기 전과 같은 시간이 걸린다.

5.  이번에는 프로세스가 입출력을 기다릴 때마다 다른 프로세스로 전환하도록 플래그를 지정하여
    같은 프로세스를 실행시켜 보자 (-l 1:0,4:100 -c -S SWITCH_ON_IO). 이제 어떤 결과가 발생하는가?
    -c를 사용하여 예측이 맞는지 확인하시오.

A.  3번 문제와 같은 결과가 나타난다.

6.  또 다른 중요한 행동은 입출력이 완료되었을 때 무엇을 하느냐이다.
    -I IO_RUN_LATER 가 지정되면 입출력이 완료되었을 때 입출력을 요청한 프로세스가 바로 실행될 필요가 없다.
    완료 시점에 실행 중이던 프로세스가 계속 실행된다. 다음과 같은 조합의 프로 세스를 실행시키면 무슨 결과가 나오는가?
    (./process-run.py -l 3:0, 5:100, 5:100, 5:100 -S SWITCH_ON_IO -I IO_RUN_LATER -c -p)
    시스템 자원은 효과적으로 활용되는가?

    IO 작업을 하는 프로세스가 바로 실행될 필요없이 나중에 실행될 수 있도록 스케줄링하면 다른 프로세스의 실행이 모두 종료되고
    IO 작업을 하게 될 수도 있게되기 때문에 시스템 자원이 비효율적으로 활용될 여지가 생긴다.

7.  같은 프로세스 조합을 실행시킬 때 -I IO_RUN_IMMEDIATE를 지정하고 실행시키시오. 
    이 플래그는 입출력이 완료되었을 때 요청 프로세스가 곧바로 실행되는 동작을 의미한다. 
    이 동작은 어떤 결과를 만들어 내는가? 방금 입출력을 완료한 프로세스를 다시 실행시키는 것이 좋은 생각일 수 있는 이유는 무엇인가?

A.  IO 작업을 하는 프로세스가 대기상태일 때 다른 프로세스가 실행되기 때문에 시스템 자원이 비교적 효율적으로 활용된다.

8.  이제 다음과 같이 무작위로 생성된 프로세스를 실행시켜보자.
    예를들면,-s 1 -l 3:50,3:50, -s 2 -l 3:50,3:50, -s 3 -l 3:50,3:50.
    어떤 양상을 보일지 예측할 수 있는지 생각해 보시오. 
    -I IO_RUN_IMMEDIATE를 지정했을 때와 -I IO_RUN_LATER를 지정했을 때 어떤 결과가 나오는가? 
    -S SWITCH_ON_IO 대 -S SWITCH_ON_END의 경우에는 어떤 결과가 나오는가?

A.  같은 시드값을 가지는 상황 하에서
    IO_RUN_IMMEDIATE와 IO_RUN_LATER 사이에는 대부분 비슷한 결과가 나타나지만
    몇몇 경우에 IO_RUN_LATER가 효율적으로 스케줄링되었다.
    그 이유는 여러 프로세스가 공평하게 스케줄링되어야 효율적으로 시스템 자원을 활용할 수 있기 때문이다.
    SWITCH_ON_IO와 SWITCH_ON_END 사이에서는 SWITCH_ON_IO가 효율적으로 나타난다.
    SWITCH_ON_END일 경우 3번 문제의 경우와 같이 대기 상태동안 다른 프로세스가 실행될 수 없기 때문에
    비효율적이다.

