1.  null.c라는 간단한 프로그램을 작성하라. 
    이 프로그램은 정수를 가리키는 포인터를 만들고 NULL로 초기화하고 그것을 역참조하려고 한다. 
    null이라는 실행 파일이 생성되도록 컴파일하라. 프로그램을 실행시키면 어떤 일이 발생하는가?

A.  segmentation fault가 발생한다.

2.  다음에 이 프로그램을 심볼 정보가 포함되도록 컴파일하라(-g 플래그 사용). 
    실행 파일에 더 많은 정보를 추가하여 디버거가 변수 이름 등의 유용한 정보를 접근할 수 있게 한다. 
    디버거에서 프로그램을 실행하라(gdb null). gdb가 실행되면, run 명령어를 입력하라. gdb는 무엇을 보여주는가?

A.

3.  마지막으로, 이 프로그램에 valgrind 도구를 사용하라. 
    우리는 valgrind의 일부 인 memcheck 도구를 사용하여 어떤 일이 일어나는지 분석할 것이다. 
    다음과 같은 명령어를 실행시켜라 : valgrind - -leak-check=yes null. 
    이를 실행하면 어떻게 되는가? 출력을 해석할 수 있는가?

A.  

4.  malloc()을 사용하여 메모리를 할당하지만 종료 전에 해제하는 것을 잊어버리는 간단한 프로그램을 작성하라. 
    이 프로그램을 실행시키면 무슨 일이 일어나는가? 이 프로그램의 문제를 gdb를 사용하여 발견할 수 있는가? 
    valgrind는 어떤가(다시 - -leak-check=yes 플래그를 주고 실행)?

A.

5.  크기가 100인 data라는 이름의 정수 배열을 만드는 프로그램을 작성하라. 
    그런 후 data[I00]을 0으로 클리어 하라. 이 프로그램을 실행하면 어떤 일이 벌어지는가? 
    valgrind를 사용하여 프로그램을 실행하면 어떤 일이 일어나는가? 프로그램은 정확한가?

A.

6.  정수 배열을 할당하고(위와 동일), 다시 해제하고, 배열의 원소 하나의 값을 출력하려고 시도하는 프로그램을 작성하라. 
    프로그램이 실행되는가? Valgrind를 사용하여 실행하면 어떤 일이 발생하는가?

A.

7.  free에 위에서 할당한 배열의 중간을 가리키는 포인터와 같은 황당한 값을 전달하라.
    어떤 일이 벌어지는가? 이런 종류의 문제를 발견하기 위해 도구가 필요한가?

A.

8.  메모리를 할당할 때 다른 인터페이스를 사용해 보라. 
    예를 들어, 간단한 벡터-비슷한 자료 구조를 만들고 벡터를 관리하기 위하여 realloc()을 사용하는 루틴을 만들어라. 
    벡터 원소를 저장하기 위하여 배열을 사용하라. 
    사용자가 벡터에 항목을 추가할 때, realloc()을 사용하여 필요 공간을 확보하라. 
    이 벡터 프로그램은 얼마나 잘 동작하는가? 
    연결 리스트와 비교하면 어떠한가? 버그를 발견하기 위하여 valgrind를 사용하라.

A.

9.  gdb와 valgrind 사용법을 배우기 위하여 시간과 노력을 투자하라. 도구를 잘 아는 것은 매우 중요하다. 
    Unix와 C 환경에서 디버거 전문가가 되기 위해 시간과 노력을 투자하라.


A.